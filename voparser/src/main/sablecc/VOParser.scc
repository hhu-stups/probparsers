Package de.prob.voparser;

/*******************************************************************
 * Helpers                                                         *
 *******************************************************************/
Helpers
  small_letter = ['a'..'z'];
  capital_letter = ['A' .. 'Z'];
  letter = small_letter | capital_letter;
  digit = ['0' .. '9'];

  underscore = '_';

  line_break = [10 + 13];
  layout_char = [[[[0 .. 32] - line_break] + [127..160]] + [[8206 .. 8207] + [8232 .. 8233]]];
  white_space = line_break | layout_char+;

  l_paren = '(';
  r_paren = ')';

  opt_white_space = layout_char*; // note: no newline (so as not to disturb counting); no comments
  dot = '.';
  comma = ',';

  identifier_literal = (letter | underscore) (letter | underscore | digit | dot | comma)*;

/*******************************************************************
 * States                                                          *
 *******************************************************************/
States
  vo;

/*******************************************************************
 * Tokens                                                          *
 *******************************************************************/
Tokens
  {vo} l_par = l_paren;
  {vo} r_par = r_paren;

  /* Boolean Operators */
  {vo} implies = '=>' | 0x21d2 | 'implies';
  {vo} equivalent = '<=>' | 0x21d4 | 'equivalent';
  {vo} and = '&' | 0x2227 | 'and';
  {vo} or = 'or' | 0x2228 | '||';
  {vo} not = 'not' | 0x00ac;

  /* Sequential Operator*/
  {vo} sequential = ';';

  {vo} identifier_literal = identifier_literal;

  white_space = white_space;

/*******************************************************************
 * Ignored Tokens                                                  *
 *******************************************************************/
Ignored Tokens
  white_space;

/*******************************************************************
 * Productions                                                     *
 *******************************************************************/
Productions

  vo_formula {-> vo} =
    {equivalent} [left]:vo_formula equivalent [right]:vo_formula1 {-> New vo.equivalent(left.vo, right.vo)} |
    vo_formula1 {-> vo_formula1.vo};

  vo_formula1 {-> vo} =
    {implication} [left]:vo_formula1 implies [right]:vo_formula2 {-> New vo.implies(left.vo, right.vo)} |
    vo_formula2 {-> vo_formula2.vo};

  vo_formula2 {-> vo} =
    {and} [left]:vo_formula2 and [right]:vo_formula3 {-> New vo.and(left.vo, right.vo)} |
    {or} [left]:vo_formula2 or [right]:vo_formula3 {-> New vo.or(left.vo, right.vo)} |
    vo_formula3 {-> vo_formula3.vo};

  vo_formula3 {-> vo} =
    {sequential} [left]:vo_formula3 sequential [right]:vo_formula4 {-> New vo.sequential(left.vo, right.vo)} |
    vo_formula4 {-> vo_formula4.vo};

  vo_formula4 {-> vo} =
    {not} not vo_formula5 {-> New vo.not(vo_formula5.vo) };

  vo_formula5 {-> vo} =
    {par} l_par vo_formula r_par {-> vo_formula.vo};

/*******************************************************************
 * Abstract Syntax Tree                                            *
 *******************************************************************/

Abstract Syntax Tree
  vo =
   {implies} [left]:vo [right]:vo |
   {equivalent} [left]:vo [right]:vo |
   {and} [left]:vo [right]:vo |
   {or} [left]:vo [right]:vo |
   {not} vo |
   {sequential} [left]:vo [right]:vo;
